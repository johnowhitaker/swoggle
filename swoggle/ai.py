# AUTOGENERATED! DO NOT EDIT! File to edit: dev/01_ai.ipynb (unless otherwise specified).

__all__ = ['RandomAgent', 'BasicAgent', 'win_rates']

# Cell
from .core import *
import random
class RandomAgent:
    """ Given a swoggle board on which it is a player, make a random valid move """

    def __init__(self, player):
        self.player = player

    def move(self, board, dice_roll):

        # If in jail, try to escape
        if self.player in board.jail:
            board.move(self.player, (0, 0), (0, 0), dice_roll, False, False)
            return 'escape'

        # Get start_loc
        start_loc = (9, 9)
        for row in board.board:
            for cell in row:
                if cell.player == self.player:
                    start_loc = (cell.y, cell.x)
        if start_loc == (9, 9):
            return None

        # Make a random move within reach
        move = ()
        count = 0
        while True:
            count += 1
            end_x = random.choice(range(8))
            end_y = random.choice(range(8))
            drone = random.choice([True, False])
            powerjump = random.choice([True, False])
            valid = board.is_valid_move(self.player, start_loc, (end_x, end_y), dice_roll, drone=drone, powerjump=powerjump)
            move = ()
            if valid:
                move = ((self.player, start_loc, (end_x, end_y), dice_roll, drone, powerjump))
#                 print(f'{self.player} took {count} tries to guess a random move')
                break
        board.move(*move)
        return move


# Cell
class BasicAgent:
    """ Given a swoggle board on which it is a player, make a sensible move """

    def __init__(self, player):
        self.player = player

    def move(self, board, dice_roll):

        # If in jail, try to escape
        if self.player in board.jail:
            board.move(self.player, (0, 0), (0, 0), dice_roll, False, False)
            return 'escape'

        # Get start_loc
        start_loc = (9, 9)
        for row in board.board:
            for cell in row:
                if cell.player == self.player:
                    start_loc = (cell.y, cell.x)
        if start_loc == (9, 9):
            return None


        # If bases in range, take them

        for row in board.board:
            for cell in row:
                if cell.player == None and cell.base != None and cell.base != self.player: # Normal move
                    move = (self.player, start_loc, (cell.x, cell.y), dice_roll, False, False)
                    if board.is_valid_move(*move):
                        board.move(*move)
                        return (move)

                if cell.base != None and cell.base != self.player: # Drone attack
                    move = (self.player, start_loc, (cell.x, cell.y), dice_roll, True, False)
                    if board.is_valid_move(*move):
                        board.move(*move)
                        return (move)

        # If on base and player in range, take or powerjump them
        if board.board[start_loc[0]][start_loc[1]].base == self.player:
            for row in board.board:
                for cell in row:
                    if cell.player != None and cell.player != self.player:
                        # try normal move
                        move = (self.player, start_loc, (cell.x, cell.y), dice_roll, False, False)
                        if board.is_valid_move(*move):
                            board.move(*move)
                            return (move)
                        # Try powerjump
                        move = (self.player, start_loc, (cell.x, cell.y), dice_roll, False, True)
                        if board.is_valid_move(*move):
                            board.move(*move)
                            return (move)

        # If players in range and takeable, take them
        for row in board.board:
            for cell in row:
                if cell.player != None and cell.player != self.player:
                    # Normal take
                    move = (self.player, start_loc, (cell.x, cell.y), dice_roll, False, False)
                    if board.is_valid_move(*move):
                        board.move(*move)
                        return (move)
                    # Drone take
                    move = (self.player, start_loc, (cell.x, cell.y), dice_roll, True, False)
                    if board.is_valid_move(*move):
                        board.move(*move)
                        return (move)

        # TODO: If player close to your base and base reacheable, go back to base

        # Else move randomly

        # Make a random move within reach
        move = ()
        count = 0
        while True:
            count += 1
            end_x = random.choice(range(8))
            end_y = random.choice(range(8))
            drone = random.choice([True, False])
            powerjump = random.choice([True, False])
            valid = board.is_valid_move(self.player, start_loc, (end_x, end_y), dice_roll, drone=drone, powerjump=powerjump)
            move = ()
            if valid:
                move = ((self.player, start_loc, (end_x, end_y), dice_roll, drone, powerjump))
#                 print(f'{self.player} took {count} tries to guess a random move')
                break
        board.move(*move)
        return move

# Cell
from IPython.display import clear_output

def win_rates(n, agents):
    wins = {}
    for i in range(n):
        rounds = 0
        sr = Swoggle(agents, verbose=False)
        while True:
            sr.move_agents()
            rounds += 1
            players = []
            for row in sr.board.board:
                for cell in row:
                    if cell.player != None:
                        players.append(cell.player)
            if len(players) <= 1:
                clear_output(wait=True)
                print("Winner:", players, rounds)
                if len(players) == 1:
                    if players[0] in wins:
                        wins[players[0]] += 1
                    else:
                        wins[players[0]] = 1
                break
    return wins


